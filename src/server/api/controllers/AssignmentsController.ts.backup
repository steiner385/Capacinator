import { Request, Response } from 'express';
import { BaseController } from './BaseController.js';
import { transformDates, transformDatesInArray, COMMON_DATE_FIELDS } from '../../utils/dateTransform.js';
import { notificationScheduler } from '../../services/NotificationScheduler.js';

interface AssignmentConflict {
  person_id: string;
  person_name: string;
  conflicting_projects: Array<{
    project_name: string;
    start_date: string;
    end_date: string;
    allocation_percentage: number;
  }>;
  total_allocation: number;
  available_capacity: number;
}

export class AssignmentsController extends BaseController {
  async getAll(req: Request, res: Response) {
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 50;
    const filters = {
      project_id: req.query.project_id,
      person_id: req.query.person_id,
      role_id: req.query.role_id,
      status: req.query.status
    };

    // Get scenario from header
    const scenarioId = req.headers['x-scenario-id'] as string;
    const includeAllScenarios = req.query.includeAllScenarios === 'true';

    const result = await this.executeQuery(async () => {
      let query = this.db('assignments_view')
        .join('projects', 'assignments_view.project_id', 'projects.id')
        .join('people', 'assignments_view.person_id', 'people.id')
        .join('roles', 'assignments_view.role_id', 'roles.id')
        .leftJoin('project_phases', 'assignments_view.phase_id', 'project_phases.id')
        .select(
          'assignments_view.*',
          'projects.name as project_name',
          'projects.aspiration_start',
          'projects.aspiration_finish',
          'people.name as person_name',
          'roles.name as role_name',
          'project_phases.name as phase_name'
        );

      // Filter by scenario if provided and not including all scenarios
      if (scenarioId && !includeAllScenarios) {
        query = query.where('assignments_view.scenario_id', scenarioId);
      }

      // Add date range filter using computed dates
      if (req.query.start_date) {
        query = query.where(function(this: any) {
          this.where('assignments_view.computed_end_date', '>=', req.query.start_date as string)
            .orWhere(function(this: any) {
              this.whereNull('assignments_view.computed_end_date')
                .andWhere('assignments_view.end_date', '>=', req.query.start_date as string);
            });
        });
      }
      if (req.query.end_date) {
        query = query.where(function(this: any) {
          this.where('assignments_view.computed_start_date', '<=', req.query.end_date as string)
            .orWhere(function(this: any) {
              this.whereNull('assignments_view.computed_start_date')
                .andWhere('assignments_view.start_date', '<=', req.query.end_date as string);
            });
        });
      }

      query = this.buildFilters(query, filters);
      query = this.paginate(query, page, limit);
      query = query.orderBy('assignments_view.start_date', 'desc');

      const assignments = await query;
      const total = await this.db('assignments_view').count('* as count').first();

      // Compute dates for each assignment
      const assignmentsWithComputedDates = await Promise.all(
        assignments.map(async (assignment: any) => {
          const computedDates = await this.computeAssignmentDates(assignment);
          return { ...assignment, ...computedDates };
        })
      );

      // Transform date fields from timestamps to date strings
      const transformedAssignments = transformDatesInArray(assignmentsWithComputedDates, [
        ...COMMON_DATE_FIELDS,
        'computed_start_date',
        'computed_end_date',
        'aspiration_start',
        'aspiration_finish'
      ]);

      return {
        data: transformedAssignments,
        pagination: {
          page,
          limit,
          total: Number(total?.count) || 0,
          totalPages: Math.ceil((Number(total?.count) || 0) / limit)
        }
      };
    }, res, 'Failed to fetch assignments');

    if (result) {
      res.json(result);
    }
  }

  async create(req: Request, res: Response) {
    const assignmentData = req.body;

    const result = await this.executeQuery(async () => {
      // Validate required fields
      if (!assignmentData.project_id || !assignmentData.person_id || !assignmentData.role_id) {
        return res.status(400).json({
          error: 'Missing required fields: project_id, person_id, and role_id are required'
        });
      }

      // Validate allocation percentage
      const allocation = assignmentData.allocation_percentage || 0;
      if (allocation <= 0) {
        return res.status(400).json({
          error: 'Allocation percentage must be positive'
        });
      }
      if (allocation > 200) {
        return res.status(400).json({
          error: 'Allocation percentage cannot exceed 200%'
        });
      }

      // Validate assignment_date_mode
      const validDateModes = ['fixed', 'project', 'phase'];
      if (!assignmentData.assignment_date_mode || !validDateModes.includes(assignmentData.assignment_date_mode)) {
        return res.status(400).json({
          error: 'Invalid assignment_date_mode. Must be one of: fixed, project, phase'
        });
      }

      // Validate dates based on mode
      if (assignmentData.assignment_date_mode === 'fixed') {
        if (!assignmentData.start_date || !assignmentData.end_date) {
          return res.status(400).json({
            error: 'Start date and end date are required for fixed date mode assignments'
          });
        }
        // Validate date format and order
        const startDate = new Date(assignmentData.start_date);
        const endDate = new Date(assignmentData.end_date);
        if (isNaN(startDate.getTime()) || isNaN(endDate.getTime())) {
          return res.status(400).json({
            error: 'Invalid date format. Use YYYY-MM-DD format'
          });
        }
        if (startDate > endDate) {
          return res.status(400).json({
            error: 'Start date must be before or equal to end date'
          });
        }
      } else if (assignmentData.assignment_date_mode === 'phase' && !assignmentData.phase_id) {
        return res.status(400).json({
          error: 'Phase ID is required for phase-based assignments'
        });
      }

      // Compute dates based on assignment mode
      const computedDates = await this.computeAssignmentDates(assignmentData);
      
      // Use computed dates for conflict checking
      const effectiveStartDate = computedDates.computed_start_date || assignmentData.start_date;
      const effectiveEndDate = computedDates.computed_end_date || assignmentData.end_date;

      // Ensure we have valid dates for the assignment
      if (!effectiveStartDate || !effectiveEndDate) {
        return res.status(400).json({
          error: 'Unable to determine assignment dates. Check project/phase configuration.'
        });
      }

      // Get scenario from header
      const scenarioId = req.headers['x-scenario-id'] as string || 'baseline-0000-0000-0000-000000000000';

      // Check for conflicts before creating
      const conflicts = await this.checkConflicts(
        assignmentData.person_id,
        effectiveStartDate,
        effectiveEndDate,
        assignmentData.allocation_percentage,
        undefined,
        scenarioId
      );

      let warning = null;
      if (conflicts && conflicts.total_allocation > 100) {
        warning = `Person will be overallocated at ${conflicts.total_allocation}% during this period`;
      }
      
      const [assignment] = await this.db('scenario_project_assignments')
        .insert({
          ...assignmentData,
          ...computedDates,
          scenario_id: scenarioId,
          created_at: new Date(),
          updated_at: new Date()
        })
        .returning('*');

      // Return assignment with computed dates
      const assignmentWithDates = { ...assignment, ...computedDates };
      
      // Send notification for assignment creation
      try {
        await notificationScheduler.sendAssignmentNotification(
          assignmentData.person_id,
          'created',
          assignmentData
        );
      } catch (error) {
        console.error('Failed to send assignment notification:', error);
      }
      
      const response = transformDates(assignmentWithDates, [
        ...COMMON_DATE_FIELDS,
        'computed_start_date',
        'computed_end_date'
      ]);
      
      // Add warning if person is overallocated
      if (warning && conflicts) {
        return {
          ...response,
          warning,
          totalAllocation: conflicts.total_allocation
        };
      }
      
      return response;
    }, res, 'Failed to create assignment');

    if (result) {
      res.status(201).json(result);
    }
  }

  async getById(req: Request, res: Response) {
    const { id } = req.params;

    const result = await this.executeQuery(async () => {
      // Check if this is a scenario assignment
      const isScenarioAssignment = id.startsWith('spa-');
      
      let assignment;
      if (isScenarioAssignment) {
        // Remove the 'spa-' prefix to get the actual ID
        const actualId = id.substring(4);
        assignment = await this.db('scenario_project_assignments')
          .join('projects', 'scenario_project_assignments.project_id', 'projects.id')
          .join('people', 'scenario_project_assignments.person_id', 'people.id')
          .join('roles', 'scenario_project_assignments.role_id', 'roles.id')
          .join('scenarios', 'scenario_project_assignments.scenario_id', 'scenarios.id')
          .select(
            'scenario_project_assignments.*',
            'projects.name as project_name',
            'people.name as person_name',
            'roles.name as role_name',
            'scenarios.name as scenario_name'
          )
          .where('scenario_project_assignments.id', actualId)
          .where('scenarios.status', 'active')
          .first();
          
        if (assignment) {
          // Add the spa- prefix back to the ID
          assignment.id = 'spa-' + assignment.id;
          assignment.assignment_type = 'scenario';
        }
      } else {
        assignment = await this.db('project_assignments')
          .join('projects', 'project_assignments.project_id', 'projects.id')
          .join('people', 'project_assignments.person_id', 'people.id')
          .join('roles', 'project_assignments.role_id', 'roles.id')
          .select(
            'project_assignments.*',
            'projects.name as project_name',
            'people.name as person_name',
            'roles.name as role_name'
          )
          .where('project_assignments.id', id)
          .first();
          
        if (assignment) {
          assignment.assignment_type = 'direct';
        }
      }

      if (!assignment) {
        this.handleNotFound(res, 'Assignment');
        return null;
      }

      return transformDates(assignment, COMMON_DATE_FIELDS);
    }, res, 'Failed to fetch assignment');

    if (result) {
      res.json(result);
    }
  }

  async update(req: Request, res: Response) {
    const { id } = req.params;
    const updateData = req.body;

    const result = await this.executeQuery(async () => {
      // Check for assignment in scenario table first, then fall back to legacy table
      let existing;
      let tableName = 'scenario_project_assignments';
      let actualId = id;
      let isScenarioAssignment = true;
      
      // Remove 'spa-' prefix if present for backward compatibility
      if (id.startsWith('spa-')) {
        actualId = id.substring(4);
      }
      
      existing = await this.db(tableName).where('id', actualId).first();
      
      // If not found in scenario table, check legacy table
      if (!existing) {
        tableName = 'project_assignments';
        isScenarioAssignment = false;
        existing = await this.db(tableName).where('id', actualId).first();
      }
      
      if (!existing) {
        this.handleNotFound(res, 'Assignment');
        return null;
      }

      // Validate allocation percentage if provided
      if (updateData.allocation_percentage !== undefined) {
        const allocation = updateData.allocation_percentage;
        if (allocation <= 0) {
          return res.status(400).json({
            error: 'Allocation percentage must be positive'
          });
        }
        if (allocation > 200) {
          return res.status(400).json({
            error: 'Allocation percentage cannot exceed 200%'
          });
        }
      }

      // Validate date mode if it's being changed
      if (updateData.assignment_date_mode) {
        const validDateModes = ['fixed', 'project', 'phase'];
        if (!validDateModes.includes(updateData.assignment_date_mode)) {
          return res.status(400).json({
            error: 'Invalid assignment_date_mode. Must be one of: fixed, project, phase'
          });
        }
      }

      // Determine the effective date mode
      const dateMode = updateData.assignment_date_mode || existing.assignment_date_mode;

      // Validate dates based on mode
      if (dateMode === 'fixed') {
        const startDate = updateData.start_date || existing.start_date;
        const endDate = updateData.end_date || existing.end_date;
        
        if (!startDate || !endDate) {
          return res.status(400).json({
            error: 'Start date and end date are required for fixed date mode assignments'
          });
        }

        // Validate date format and order if dates are being updated
        if (updateData.start_date || updateData.end_date) {
          const start = new Date(startDate);
          const end = new Date(endDate);
          if (isNaN(start.getTime()) || isNaN(end.getTime())) {
            return res.status(400).json({
              error: 'Invalid date format. Use YYYY-MM-DD format'
            });
          }
          if (start > end) {
            return res.status(400).json({
              error: 'Start date must be before or equal to end date'
            });
          }
        }
      } else if (dateMode === 'phase') {
        const phaseId = updateData.phase_id || existing.phase_id;
        if (!phaseId) {
          return res.status(400).json({
            error: 'Phase ID is required for phase-based assignments'
          });
        }
      }

      // Compute dates for the updated assignment
      const assignmentForComputation = { ...existing, ...updateData };
      const computedDates = await this.computeAssignmentDates(assignmentForComputation);
      
      // Use computed dates for conflict checking
      const effectiveStartDate = computedDates.computed_start_date || updateData.start_date || existing.start_date;
      const effectiveEndDate = computedDates.computed_end_date || updateData.end_date || existing.end_date;

      // Ensure we have valid dates
      if (!effectiveStartDate || !effectiveEndDate) {
        return res.status(400).json({
          error: 'Unable to determine assignment dates. Check project/phase configuration.'
        });
      }

      // Check conflicts if dates or allocation changed
      let warning = null;
      let totalAllocation = null;
      
      // Get scenario from existing assignment or header
      const scenarioId = existing.scenario_id || req.headers['x-scenario-id'] as string || 'baseline-0000-0000-0000-000000000000';
      
      if (updateData.start_date || updateData.end_date || updateData.allocation_percentage || 
          updateData.assignment_date_mode || updateData.phase_id) {
        const conflict = await this.checkConflicts(
          updateData.person_id || existing.person_id,
          effectiveStartDate,
          effectiveEndDate,
          updateData.allocation_percentage || existing.allocation_percentage,
          id, // Exclude current assignment
          scenarioId
        );

        if (conflict && conflict.total_allocation > 100) {
          warning = `Person will be overallocated at ${conflict.total_allocation}% during this period`;
          totalAllocation = conflict.total_allocation;
        }
      }

      // Update assignment
      const [updated] = await this.db(tableName)
        .where('id', actualId)
        .update({
          ...updateData,
          updated_at: new Date()
        })
        .returning('*');
        
      // Add back the spa- prefix if it's a scenario assignment
      if (isScenarioAssignment && updated) {
        updated.id = 'spa-' + updated.id;
      }

      // Send notification for assignment update
      try {
        await notificationScheduler.sendAssignmentNotification(
          updateData.person_id || existing.person_id,
          'updated',
          { ...existing, ...updateData }
        );
      } catch (error) {
        console.error('Failed to send assignment notification:', error);
      }

      const response = transformDates(updated, COMMON_DATE_FIELDS);
      
      // Add warning if person is overallocated
      if (warning) {
        return {
          ...response,
          warning,
          currentTotalAllocation: totalAllocation
        };
      }
      
      return response;
    }, res, 'Failed to update assignment');

    if (result) {
      res.json(result);
    }
  }

  async delete(req: Request, res: Response) {
    const { id } = req.params;

    const result = await this.executeQuery(async () => {
      // Check if this is a scenario assignment
      const isScenarioAssignment = id.startsWith('spa-');
      let deleted;
      
      if (isScenarioAssignment) {
        const actualId = id.substring(4); // Remove 'spa-' prefix
        deleted = await this.db('scenario_project_assignments')
          .where('id', actualId)
          .del();
      } else {
        deleted = await this.db('project_assignments')
          .where('id', id)
          .del();
      }

      if (deleted === 0) {
        this.handleNotFound(res, 'Assignment');
        return null;
      }

      return { message: 'Assignment deleted successfully' };
    }, res, 'Failed to delete assignment');

    if (result) {
      res.json(result);
    }
  }

  async bulkAssign(req: Request, res: Response) {
    const { project_id, assignments } = req.body;

    const result = await this.executeQuery(async () => {
      const results = {
        successful: [] as any[],
        failed: [] as any[],
        conflicts: [] as AssignmentConflict[]
      };

      // Get scenario from header
      const scenarioId = req.headers['x-scenario-id'] as string || 'baseline-0000-0000-0000-000000000000';

      // Process each assignment
      for (const assignment of assignments) {
        try {
          // Check conflicts
          const conflict = await this.checkConflicts(
            assignment.person_id,
            assignment.start_date,
            assignment.end_date,
            assignment.allocation_percentage,
            assignment.id, // Exclude current assignment if updating
            scenarioId
          );

          if (conflict && conflict.total_allocation > 100) {
            results.conflicts.push(conflict);
            results.failed.push({
              ...assignment,
              reason: 'Capacity exceeded',
              total_allocation: conflict.total_allocation
            });
            continue;
          }

          // Create assignment
          const [created] = await this.db('scenario_project_assignments')
            .insert({
              project_id,
              person_id: assignment.person_id,
              role_id: assignment.role_id,
              allocation_percentage: assignment.allocation_percentage,
              start_date: assignment.start_date,
              end_date: assignment.end_date,
              notes: assignment.notes,
              scenario_id: scenarioId,
              created_at: new Date(),
              updated_at: new Date()
            })
            .returning('*');

          results.successful.push(transformDates(created, COMMON_DATE_FIELDS));

        } catch (error) {
          results.failed.push({
            ...assignment,
            reason: error instanceof Error ? error.message : 'Unknown error'
          });
        }
      }

      return {
        summary: {
          total: assignments.length,
          successful: results.successful.length,
          failed: results.failed.length,
          conflicts: results.conflicts.length
        },
        results
      };
    }, res, 'Failed to create bulk assignments');

    if (result) {
      res.json(result);
    }
  }

  async checkConflicts(
    person_id: string,
    start_date: string,
    end_date: string,
    allocation_percentage: number,
    exclude_assignment_id?: string,
    scenarioId?: string
  ): Promise<AssignmentConflict | null> {
    // Get person details
    const person = await this.db('people')
      .where('id', person_id)
      .first();

    if (!person) return null;

    // Get scenario from header if not provided
    if (!scenarioId) {
      scenarioId = (this as any).req?.headers?.['x-scenario-id'] as string || 'baseline-0000-0000-0000-000000000000';
    }

    // Get overlapping assignments from assignments_view (includes both direct and scenario assignments)
    let query = this.db('assignments_view')
      .join('projects', 'assignments_view.project_id', 'projects.id')
      .where('assignments_view.person_id', person_id)
      .where('assignments_view.scenario_id', scenarioId)
      .where(function() {
        this.where('assignments_view.computed_start_date', '<=', end_date)
          .orWhere(function() {
            this.whereNull('assignments_view.computed_start_date')
              .andWhere('assignments_view.start_date', '<=', end_date);
          });
      })
      .where(function() {
        this.where('assignments_view.computed_end_date', '>=', start_date)
          .orWhere(function() {
            this.whereNull('assignments_view.computed_end_date')
              .andWhere('assignments_view.end_date', '>=', start_date);
          });
      });

    if (exclude_assignment_id) {
      query = query.where('assignments_view.id', '!=', exclude_assignment_id);
    }

    const overlapping = await query.select(
      'assignments_view.*',
      'projects.name as project_name'
    );

    const total_allocation = overlapping.reduce((sum: number, assignment: any) => 
      sum + assignment.allocation_percentage, allocation_percentage
    );

    // Get person's current availability
    const availability = await this.db('person_availability_view')
      .where('person_id', person_id)
      .first();

    const available_capacity = availability?.effective_availability_percentage || 100;

    if (total_allocation > available_capacity) {
      return {
        person_id,
        person_name: person.name,
        conflicting_projects: overlapping.map((a: any) => ({
          project_name: a.project_name,
          start_date: a.computed_start_date || a.start_date,
          end_date: a.computed_end_date || a.end_date,
          allocation_percentage: a.allocation_percentage
        })),
        total_allocation,
        available_capacity
      };
    }

    return null;
  }

  async getConflicts(req: Request, res: Response) {
    const { person_id } = req.params;
    const { start_date, end_date } = req.query;

    const result = await this.executeQuery(async () => {
      // Get scenario from header
      const scenarioId = req.headers['x-scenario-id'] as string || 'baseline-0000-0000-0000-000000000000';
      
      let query = this.db('assignments_view')
        .join('projects', 'assignments_view.project_id', 'projects.id')
        .where('assignments_view.person_id', person_id)
        .where('assignments_view.scenario_id', scenarioId);

      if (start_date && end_date) {
        query = query
          .where(function() {
            this.where('assignments_view.computed_start_date', '<=', end_date)
              .orWhere(function() {
                this.whereNull('assignments_view.computed_start_date')
                  .andWhere('assignments_view.start_date', '<=', end_date);
              });
          })
          .where(function() {
            this.where('assignments_view.computed_end_date', '>=', start_date)
              .orWhere(function() {
                this.whereNull('assignments_view.computed_end_date')
                  .andWhere('assignments_view.end_date', '>=', start_date);
              });
          });
      }

      const assignments = await query.select(
        'assignments_view.*',
        'projects.name as project_name'
      );

      // Transform date fields
      const transformedAssignments = transformDatesInArray(assignments, COMMON_DATE_FIELDS);

      // Group by overlapping time periods
      const conflicts = this.groupOverlappingAssignments(transformedAssignments);

      return conflicts;
    }, res, 'Failed to check conflicts');

    if (result) {
      res.json(result);
    }
  }

  async getSuggestions(req: Request, res: Response) {
    const { role_id, start_date, end_date, required_allocation } = req.query;

    const result = await this.executeQuery(async () => {
      // Get all people with the required role
      const peopleWithRole = await this.db('person_roles')
        .join('people', 'person_roles.person_id', 'people.id')
        .where('person_roles.role_id', role_id)
        .select(
          'people.*',
          'person_roles.proficiency_level'
        );

      // Check availability for each person
      const suggestions = [];

      for (const person of peopleWithRole) {
        // Get current allocations in the date range
        const allocations = await this.db('project_assignments')
          .where('person_id', person.id)
          .where('start_date', '<=', end_date as string)
          .where('end_date', '>=', start_date as string)
          .sum('allocation_percentage as total_allocation')
          .first();

        const currentAllocation = allocations?.total_allocation || 0;

        // Get availability
        const availability = await this.db('person_availability_view')
          .where('person_id', person.id)
          .first();

        const availableCapacity = (availability?.effective_availability_percentage || 100) - currentAllocation;

        if (availableCapacity >= Number(required_allocation)) {
          suggestions.push({
            person_id: person.id,
            person_name: person.name,
            proficiency_level: person.proficiency_level,
            current_allocation: currentAllocation,
            available_capacity: availableCapacity,
            availability_status: availability?.availability_status,
            score: this.calculateSuggestionScore(person, availableCapacity)
          });
        }
      }

      // Sort by score (highest first)
      suggestions.sort((a, b) => b.score - a.score);

      return {
        role_id,
        start_date,
        end_date,
        required_allocation,
        suggestions: suggestions.slice(0, 10) // Top 10 suggestions
      };
    }, res, 'Failed to get assignment suggestions');

    if (result) {
      res.json(result);
    }
  }

  async getTimeline(req: Request, res: Response) {
    const { person_id } = req.params;
    const { start_date, end_date } = req.query;

    const result = await this.executeQuery(async () => {
      // Get scenario from header
      const scenarioId = req.headers['x-scenario-id'] as string || 'baseline-0000-0000-0000-000000000000';
      
      let query = this.db('assignments_view')
        .join('projects', 'assignments_view.project_id', 'projects.id')
        .join('roles', 'assignments_view.role_id', 'roles.id')
        .where('assignments_view.person_id', person_id)
        .where('assignments_view.scenario_id', scenarioId)
        .select(
          'assignments_view.*',
          'projects.name as project_name',
          'projects.priority as project_priority',
          'roles.name as role_name'
        );

      if (start_date) {
        query = query.where(function() {
          this.where('assignments_view.computed_end_date', '>=', start_date)
            .orWhere(function() {
              this.whereNull('assignments_view.computed_end_date')
                .andWhere('assignments_view.end_date', '>=', start_date);
            });
        });
      }
      if (end_date) {
        query = query.where(function() {
          this.where('assignments_view.computed_start_date', '<=', end_date)
            .orWhere(function() {
              this.whereNull('assignments_view.computed_start_date')
                .andWhere('assignments_view.start_date', '<=', end_date);
            });
        });
      }

      const assignments = await query.orderBy(
        this.db.raw('COALESCE(assignments_view.computed_start_date, assignments_view.start_date)')
      );

      // Get availability overrides in the same period
      let availabilityQuery = this.db('person_availability_overrides')
        .where('person_id', person_id);

      if (start_date) {
        availabilityQuery = availabilityQuery.where('end_date', '>=', start_date);
      }
      if (end_date) {
        availabilityQuery = availabilityQuery.where('start_date', '<=', end_date);
      }

      const availabilityOverrides = await availabilityQuery.orderBy('start_date');

      // Transform date fields
      const transformedAssignments = transformDatesInArray(assignments, COMMON_DATE_FIELDS);
      const transformedOverrides = transformDatesInArray(availabilityOverrides, COMMON_DATE_FIELDS);

      return {
        person_id,
        timeline: {
          assignments: transformedAssignments,
          availability_overrides: transformedOverrides,
          summary: this.calculateTimelineSummary(transformedAssignments, transformedOverrides)
        }
      };
    }, res, 'Failed to get assignment timeline');

    if (result) {
      res.json(result);
    }
  }

  private groupOverlappingAssignments(assignments: any[]) {
    // Group assignments that overlap in time
    const groups = [];
    const processed = new Set();

    for (let i = 0; i < assignments.length; i++) {
      if (processed.has(i)) continue;

      const group = {
        period: {
          start: assignments[i].start_date,
          end: assignments[i].end_date
        },
        assignments: [assignments[i]],
        total_allocation: assignments[i].allocation_percentage
      };

      processed.add(i);

      // Find all overlapping assignments
      for (let j = i + 1; j < assignments.length; j++) {
        if (processed.has(j)) continue;

        if (this.datesOverlap(
          assignments[i].start_date,
          assignments[i].end_date,
          assignments[j].start_date,
          assignments[j].end_date
        )) {
          group.assignments.push(assignments[j]);
          group.total_allocation += assignments[j].allocation_percentage;
          group.period.start = this.minDate(group.period.start, assignments[j].start_date);
          group.period.end = this.maxDate(group.period.end, assignments[j].end_date);
          processed.add(j);
        }
      }

      if (group.total_allocation > 100) {
        groups.push({
          ...group,
          is_overallocated: true,
          overallocation_amount: group.total_allocation - 100
        });
      }
    }

    return groups;
  }

  private datesOverlap(start1: string, end1: string, start2: string, end2: string): boolean {
    return start1 <= end2 && end1 >= start2;
  }

  private minDate(date1: string, date2: string): string {
    return date1 < date2 ? date1 : date2;
  }

  private maxDate(date1: string, date2: string): string {
    return date1 > date2 ? date1 : date2;
  }

  private calculateSuggestionScore(person: any, availableCapacity: number): number {
    let score = 0;

    // Higher score for more available capacity
    score += availableCapacity * 0.5;

    // Higher score for higher proficiency
    const proficiencyScores: Record<string, number> = {
      'Expert': 40,
      'Senior': 30,
      'Intermediate': 20,
      'Junior': 10
    };
    score += proficiencyScores[person.proficiency_level] || 0;

    // Could add years of experience if it was in the schema
    // score += Math.min(person.years_experience * 2, 20);

    return score;
  }

  private calculateTimelineSummary(assignments: any[], availabilityOverrides: any[]) {
    const summary = {
      total_assignments: assignments.length,
      total_days_assigned: 0,
      average_allocation: 0,
      peak_allocation: 0,
      gaps: [] as any[]
    };

    if (assignments.length === 0) return summary;

    // Filter out assignments without any valid dates and use effective dates
    const validAssignments = assignments.filter(a => {
      const startDate = a.computed_start_date || a.start_date;
      const endDate = a.computed_end_date || a.end_date;
      return startDate && endDate;
    }).map(a => ({
      ...a,
      effective_start_date: a.computed_start_date || a.start_date,
      effective_end_date: a.computed_end_date || a.end_date
    }));
    
    // Calculate metrics
    let totalAllocationDays = 0;
    validAssignments.forEach(assignment => {
      const days = this.daysBetween(assignment.effective_start_date, assignment.effective_end_date);
      summary.total_days_assigned += days;
      totalAllocationDays += days * assignment.allocation_percentage;
      summary.peak_allocation = Math.max(summary.peak_allocation, assignment.allocation_percentage);
    });

    summary.average_allocation = totalAllocationDays / summary.total_days_assigned;

    // Find gaps between assignments (using filtered valid assignments)
    const sortedAssignments = [...validAssignments].sort((a, b) => {
      return a.effective_start_date.localeCompare(b.effective_start_date);
    });

    for (let i = 0; i < sortedAssignments.length - 1; i++) {
      const gap = this.daysBetween(sortedAssignments[i].effective_end_date, sortedAssignments[i + 1].effective_start_date) - 1;
      if (gap > 0) {
        summary.gaps.push({
          start: sortedAssignments[i].effective_end_date,
          end: sortedAssignments[i + 1].effective_start_date,
          days: gap
        });
      }
    }

    return summary;
  }

  async deleteTestData(req: Request, res: Response) {
    const result = await this.executeQuery(async () => {
      // Delete test assignments (ones with "Test_" in related entities)
      const deleted = await this.db('project_assignments')
        .whereIn('project_id', 
          this.db('projects').select('id').where('name', 'like', 'Test_%')
        )
        .orWhereIn('person_id',
          this.db('people').select('id').where('name', 'like', 'Test_%')  
        )
        .del();

      return { message: `Deleted ${deleted} test assignments` };
    }, res, 'Failed to delete test data');

    if (result) {
      res.json(result);
    }
  }

  private daysBetween(date1: string, date2: string): number {
    const d1 = new Date(date1);
    const d2 = new Date(date2);
    const diffTime = Math.abs(d2.getTime() - d1.getTime());
    const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));
    return diffDays;
  }

  /**
   * Compute assignment start and end dates based on assignment_date_mode
   */
  private async computeAssignmentDates(assignment: any): Promise<{
    computed_start_date?: string;
    computed_end_date?: string;
  }> {
    const mode = assignment.assignment_date_mode || 'fixed';
    
    switch (mode) {
      case 'fixed':
        // Use explicit start_date and end_date
        return {
          computed_start_date: assignment.start_date,
          computed_end_date: assignment.end_date
        };
        
      case 'phase':
        // Get dates from project phase timeline
        if (!assignment.phase_id || !assignment.project_id) {
          throw new Error('Phase mode requires both phase_id and project_id');
        }
        
        const phaseTimeline = await this.db('project_phases_timeline')
          .where('project_id', assignment.project_id)
          .where('phase_id', assignment.phase_id)
          .first();
          
        if (!phaseTimeline) {
          throw new Error(`No timeline found for phase ${assignment.phase_id} in project ${assignment.project_id}`);
        }
        
        return {
          computed_start_date: phaseTimeline.start_date,
          computed_end_date: phaseTimeline.end_date
        };
        
      case 'project':
        // Get dates from project aspiration dates
        if (!assignment.project_id) {
          throw new Error('Project mode requires project_id');
        }
        
        const project = await this.db('projects')
          .where('id', assignment.project_id)
          .first();
          
        if (!project) {
          throw new Error(`Project ${assignment.project_id} not found`);
        }
        
        if (!project.aspiration_start || !project.aspiration_finish) {
          throw new Error(`Project ${assignment.project_id} missing aspiration dates`);
        }
        
        return {
          computed_start_date: project.aspiration_start,
          computed_end_date: project.aspiration_finish
        };
        
      default:
        throw new Error(`Unknown assignment_date_mode: ${mode}`);
    }
  }
}