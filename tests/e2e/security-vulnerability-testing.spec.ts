import { test, expect } from '@playwright/test';

/**
 * Advanced Security Vulnerability Testing Suite
 * 
 * This test suite validates protection against common web security vulnerabilities:
 * - Cross-Site Scripting (XSS) - Stored and Reflected
 * - Cross-Site Request Forgery (CSRF) 
 * - SQL Injection (Advanced patterns)
 * - Content Security Policy (CSP) violations
 * - File upload vulnerabilities
 * - Session fixation and hijacking
 * - Authorization bypass attempts
 * 
 * These tests ensure the application is hardened against OWASP Top 10 vulnerabilities.
 */

// Helper function to login as a user
async function loginAsUser(page: any, personId: string = '123e4567-e89b-12d3-a456-426614174000') {
  await page.goto('/');
  await page.waitForLoadState('networkidle');
  
  const loginSelect = page.locator('#person-select');
  if (await loginSelect.count() > 0) {
    await loginSelect.selectOption(personId);
    await page.click('.login-button');
    await page.waitForLoadState('networkidle');
    await page.waitForTimeout(2000);
  }
}

test.describe('Advanced Security Vulnerability Testing', () => {
  
  test.beforeEach(async ({ page }) => {
    await loginAsUser(page);
  });

  test.describe('Cross-Site Scripting (XSS) Protection', () => {
    
    test('should prevent stored XSS in project names', async ({ page }) => {
      console.log('ðŸ”’ Testing stored XSS prevention in project creation');

      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src=x onerror=alert("XSS")>',
        'javascript:alert("XSS")',
        '<svg onload=alert("XSS")>',
        '"><script>alert("XSS")</script>',
        '<iframe src="javascript:alert(\'XSS\')"></iframe>',
        '<body onload=alert("XSS")>',
        '<div style="expression(alert(\'XSS\'))">',
        '<meta http-equiv="refresh" content="0;url=javascript:alert(\'XSS\')">'
      ];

      await page.goto('/projects');
      await page.waitForLoadState('networkidle');

      for (const payload of xssPayloads) {
        console.log(`Testing XSS payload: ${payload.substring(0, 30)}...`);
        
        // Try to create project with XSS payload
        const newButton = page.locator('button:has-text("New"), button:has-text("Add"), button:has-text("Create")');
        if (await newButton.count() > 0) {
          await newButton.first().click();
          await page.waitForTimeout(1000);

          const nameField = page.locator('input[name*="name"], input[placeholder*="name"], input[id*="name"]').first();
          if (await nameField.count() > 0) {
            await nameField.fill(payload);
            
            const submitButton = page.locator('button:has-text("Create"), button:has-text("Save"), button[type="submit"]');
            if (await submitButton.count() > 0) {
              await submitButton.click();
              await page.waitForTimeout(2000);
            }
          }

          // Close modal if still open
          const modal = page.locator('.modal, .dialog, .modal-content');
          if (await modal.count() > 0) {
            const closeButton = page.locator('button:has-text("Cancel"), button:has-text("Close"), .modal-close, [aria-label="Close"]');
            if (await closeButton.count() > 0) {
              await closeButton.first().click();
              await page.waitForTimeout(500);
            }
          }
        }

        // Verify XSS was not executed
        const alertsTriggered = await page.evaluate(() => {
          return window.location.href.includes('alert') || document.querySelector('script') !== null;
        });
        
        expect(alertsTriggered).toBe(false);
        console.log(`âœ… XSS payload properly sanitized: ${payload.substring(0, 20)}...`);
      }
    });

    test('should prevent reflected XSS in search parameters', async ({ page }) => {
      console.log('ðŸ”’ Testing reflected XSS prevention in search');

      const reflectedXSSPayloads = [
        '<script>alert("Reflected XSS")</script>',
        '"><img src=x onerror=alert("XSS")>',
        'javascript:alert(document.cookie)',
        '%3Cscript%3Ealert("XSS")%3C/script%3E'
      ];

      for (const payload of reflectedXSSPayloads) {
        console.log(`Testing reflected XSS: ${payload.substring(0, 30)}...`);
        
        // Test in assignments search
        await page.goto('/assignments');
        await page.waitForLoadState('networkidle');
        
        const searchField = page.locator('input[placeholder*="search"], input[name*="search"], input[type="search"]').first();
        if (await searchField.count() > 0) {
          await searchField.fill(payload);
          await page.waitForTimeout(1000);
        }

        // Check if XSS executed
        const pageContent = await page.content();
        expect(pageContent).not.toContain('<script>');
        expect(pageContent).not.toContain('javascript:');
        console.log(`âœ… Reflected XSS prevented: ${payload.substring(0, 20)}...`);
      }
    });

    test('should sanitize user input in person profiles', async ({ page }) => {
      console.log('ðŸ”’ Testing XSS prevention in person profile fields');

      await page.goto('/people');
      await page.waitForLoadState('networkidle');

      const xssInProfilePayloads = [
        '<script>document.cookie="hijacked=true"</script>',
        '<img src="x" onerror="fetch(\'/api/people\').then(r=>r.json()).then(d=>console.log(d))">',
        '<svg><script>window.location="http://malicious.com"</script></svg>'
      ];

      const newButton = page.locator('button:has-text("New"), button:has-text("Add")');
      if (await newButton.count() > 0) {
        await newButton.first().click();
        await page.waitForTimeout(1000);

        for (const payload of xssInProfilePayloads) {
          console.log(`Testing profile XSS: ${payload.substring(0, 30)}...`);
          
          // Try different profile fields
          const fields = [
            'input[name*="name"]',
            'input[name*="email"]', 
            'textarea[name*="notes"]',
            'input[placeholder*="name"]'
          ];

          for (const fieldSelector of fields) {
            const field = page.locator(fieldSelector).first();
            if (await field.count() > 0) {
              await field.fill(payload);
              await page.waitForTimeout(500);
            }
          }
        }

        // Try to submit
        const submitButton = page.locator('button:has-text("Create"), button:has-text("Save")');
        if (await submitButton.count() > 0) {
          await submitButton.click();
          await page.waitForTimeout(2000);
        }

        // Verify no XSS execution
        const maliciousCookies = await page.evaluate(() => document.cookie.includes('hijacked'));
        expect(maliciousCookies).toBe(false);
        console.log('âœ… Person profile XSS attacks prevented');
      }
    });
  });

  test.describe('Cross-Site Request Forgery (CSRF) Protection', () => {
    
    test('should require proper authentication for state-changing operations', async ({ page, context }) => {
      console.log('ðŸ”’ Testing CSRF protection for critical operations');

      // Get current session info
      const cookies = await context.cookies();
      const sessionCookie = cookies.find(c => c.name.includes('session') || c.name.includes('auth'));

      // Test CSRF protection on different endpoints
      const csrfTargets = [
        { method: 'POST', path: '/api/projects', action: 'project creation' },
        { method: 'PUT', path: '/api/people/test-id', action: 'person update' },
        { method: 'DELETE', path: '/api/assignments/test-id', action: 'assignment deletion' },
        { method: 'POST', path: '/api/assignments', action: 'assignment creation' }
      ];

      for (const target of csrfTargets) {
        console.log(`Testing CSRF protection for ${target.action}`);
        
        // Simulate external site making request without proper headers
        const response = await page.request.fetch(target.path, {
          method: target.method,
          headers: {
            'Content-Type': 'application/json',
            'Origin': 'https://malicious-site.com',
            'Referer': 'https://malicious-site.com/attack'
          },
          data: JSON.stringify({
            name: 'CSRF Attack Test',
            malicious: true
          })
        });

        // Should be rejected (401/403) or require additional validation
        expect([400, 401, 403, 422, 405].includes(response.status())).toBe(true);
        console.log(`âœ… CSRF protection active for ${target.action} (status: ${response.status()})`);
      }
    });

    test('should validate origin headers for API requests', async ({ page }) => {
      console.log('ðŸ”’ Testing origin header validation');

      await page.goto('/assignments');
      await page.waitForLoadState('networkidle');

      // Monitor API requests for proper origin validation
      const apiRequests = [];
      page.on('request', request => {
        if (request.url().includes('/api/')) {
          apiRequests.push({
            url: request.url(),
            method: request.method(),
            headers: request.headers()
          });
        }
      });

      // Trigger some API calls
      await page.reload();
      await page.waitForLoadState('networkidle');
      await page.goto('/people');
      await page.waitForLoadState('networkidle');

      // Verify legitimate requests have proper origins
      const legitimateRequests = apiRequests.filter(req => 
        req.headers.origin && req.headers.origin.includes('localhost')
      );
      
      expect(legitimateRequests.length).toBeGreaterThan(0);
      console.log(`âœ… Origin validation working: ${legitimateRequests.length} legitimate requests`);
    });
  });

  test.describe('Advanced SQL Injection Protection', () => {
    
    test('should prevent advanced SQL injection techniques', async ({ page }) => {
      console.log('ðŸ”’ Testing advanced SQL injection prevention');

      const advancedSQLPayloads = [
        // Union-based injection
        "' UNION SELECT username, password FROM users--",
        "' UNION SELECT NULL, table_name FROM information_schema.tables--",
        
        // Boolean-based blind injection
        "' AND (SELECT COUNT(*) FROM users) > 0--",
        "' AND (SELECT SUBSTR(password,1,1) FROM users WHERE username='admin')='a'--",
        
        // Time-based blind injection
        "'; WAITFOR DELAY '00:00:10'--",
        "' AND (SELECT COUNT(*) FROM people) > 0 AND SLEEP(5)--",
        
        // Second-order injection
        "admin'; INSERT INTO people (name) VALUES ('injected')--",
        
        // NoSQL injection attempts
        "'; return true; var a='",
        "' || '1'=='1",
        
        // JSON injection
        '{"$ne": null}',
        '{"$where": "this.username == this.password"}',
        
        // XML injection
        "'; SELECT * FROM xmltable('//user')--",
        
        // Advanced bypass techniques
        "' /**/UNION/**/SELECT/**/NULL--",
        "' UNI/**/ON SE/**/LECT NULL--",
        "' %55nion %53elect null--",
        "' +union+select+null--"
      ];

      await page.goto('/assignments');
      await page.waitForLoadState('networkidle');

      for (const payload of advancedSQLPayloads) {
        console.log(`Testing advanced SQL injection: ${payload.substring(0, 40)}...`);
        
        // Test in search field
        const searchField = page.locator('input[placeholder*="search"], input[name*="search"]').first();
        if (await searchField.count() > 0) {
          await searchField.fill(payload);
          await page.waitForTimeout(1000);
          
          // Check for SQL errors in response
          const pageContent = await page.content();
          const hasError = pageContent.toLowerCase().includes('sql') || 
                          pageContent.toLowerCase().includes('sqlite') ||
                          pageContent.toLowerCase().includes('syntax error') ||
                          pageContent.toLowerCase().includes('database error');
          
          expect(hasError).toBe(false);
        }

        // Test in API calls directly
        try {
          const response = await page.request.get(`/api/assignments?search=${encodeURIComponent(payload)}`);
          const responseText = await response.text();
          
          // Should not reveal database errors
          expect(responseText.toLowerCase()).not.toContain('sqlite');
          expect(responseText.toLowerCase()).not.toContain('sql error');
          expect(responseText.toLowerCase()).not.toContain('syntax error');
          
        } catch (error) {
          // Request might fail, but shouldn't reveal database structure
          console.log(`SQL injection attempt blocked: ${payload.substring(0, 20)}...`);
        }
      }
      
      console.log('âœ… Advanced SQL injection protection verified');
    });

    test('should protect against database fingerprinting', async ({ page }) => {
      console.log('ðŸ”’ Testing database fingerprinting protection');

      const fingerprintingPayloads = [
        "' AND sqlite_version()>0--",
        "' AND (SELECT name FROM sqlite_master WHERE type='table' LIMIT 1)='users'--",
        "' AND (SELECT sql FROM sqlite_master WHERE name='people')--",
        "'; SELECT sql FROM sqlite_master--",
        "' AND (SELECT COUNT(*) FROM pragma_table_info('people'))>0--"
      ];

      for (const payload of fingerprintingPayloads) {
        console.log(`Testing DB fingerprinting: ${payload.substring(0, 30)}...`);
        
        const response = await page.request.get(`/api/people?search=${encodeURIComponent(payload)}`);
        const responseText = await response.text();
        
        // Should not reveal database schema information
        expect(responseText.toLowerCase()).not.toContain('sqlite_master');
        expect(responseText.toLowerCase()).not.toContain('pragma_');
        expect(responseText.toLowerCase()).not.toContain('information_schema');
        
        console.log(`âœ… DB fingerprinting blocked: ${payload.substring(0, 20)}...`);
      }
    });
  });

  test.describe('File Upload and Content Security', () => {
    
    test('should validate file upload restrictions', async ({ page }) => {
      console.log('ðŸ”’ Testing file upload security');

      // Test malicious file uploads if upload functionality exists
      await page.goto('/people');
      await page.waitForLoadState('networkidle');

      const fileInputs = await page.locator('input[type="file"]').count();
      
      if (fileInputs > 0) {
        console.log('Found file upload functionality, testing security...');
        
        // Test various malicious file types
        const maliciousFiles = [
          { name: 'malicious.php', content: '<?php system($_GET["cmd"]); ?>' },
          { name: 'exploit.jsp', content: '<% Runtime.getRuntime().exec("rm -rf /"); %>' },
          { name: 'script.js', content: 'alert("XSS via file upload");' },
          { name: 'test.html', content: '<script>document.location="http://evil.com"</script>' }
        ];

        for (const file of maliciousFiles) {
          console.log(`Testing malicious file upload: ${file.name}`);
          
          // Create temporary file
          const fileInput = page.locator('input[type="file"]').first();
          
          // Note: In a real test, you'd create actual files with malicious content
          // This is a simplified test structure
          try {
            // Simulate file upload attempt
            await fileInput.setInputFiles({
              name: file.name,
              mimeType: 'text/plain',
              buffer: Buffer.from(file.content)
            });
            
            // Check if upload was rejected
            await page.waitForTimeout(2000);
            
            // Look for error messages indicating rejection
            const errorMessage = await page.locator('.error, .alert-error, [data-testid="error"]').count();
            if (errorMessage > 0) {
              console.log(`âœ… Malicious file ${file.name} properly rejected`);
            }
            
          } catch (error) {
            console.log(`âœ… File upload ${file.name} blocked by validation`);
          }
        }
      } else {
        console.log('â„¹ï¸ No file upload functionality found');
      }
    });

    test('should enforce Content Security Policy', async ({ page }) => {
      console.log('ðŸ”’ Testing Content Security Policy enforcement');

      await page.goto('/dashboard');
      await page.waitForLoadState('networkidle');

      // Check for CSP headers
      const response = await page.goto('/dashboard');
      const headers = response?.headers();
      
      if (headers && headers['content-security-policy']) {
        const csp = headers['content-security-policy'];
        console.log('CSP found:', csp);
        
        // Verify CSP contains security directives
        expect(csp).toContain('default-src');
        expect(csp).toContain('script-src');
        
        console.log('âœ… Content Security Policy is configured');
      } else {
        console.log('âš ï¸ No Content Security Policy found - consider implementing');
      }

      // Test inline script blocking (if CSP is strict)
      const inlineScriptBlocked = await page.evaluate(() => {
        try {
          const script = document.createElement('script');
          script.textContent = 'window.maliciousCode = true;';
          document.head.appendChild(script);
          return !window.maliciousCode;
        } catch (error) {
          return true; // Script was blocked
        }
      });

      if (inlineScriptBlocked) {
        console.log('âœ… Inline scripts properly blocked by CSP');
      } else {
        console.log('âš ï¸ Inline scripts not blocked - consider stricter CSP');
      }
    });
  });

  test.describe('Session Security and Authorization Bypass', () => {
    
    test('should prevent session fixation attacks', async ({ page, context }) => {
      console.log('ðŸ”’ Testing session fixation protection');

      // Clear all cookies to start fresh
      await context.clearCookies();
      
      // Set a predefined session ID (simulating fixation attempt)
      await context.addCookies([{
        name: 'session_id',
        value: 'attacker_controlled_session_123',
        domain: 'localhost',
        path: '/'
      }]);

      // Attempt login
      await loginAsUser(page);

      // Check if session ID changed after login
      const cookiesAfterLogin = await context.cookies();
      const sessionAfterLogin = cookiesAfterLogin.find(c => c.name === 'session_id');
      
      if (sessionAfterLogin) {
        expect(sessionAfterLogin.value).not.toBe('attacker_controlled_session_123');
        console.log('âœ… Session fixation prevented - session ID regenerated');
      } else {
        console.log('â„¹ï¸ No persistent session cookies found');
      }
    });

    test('should prevent authorization bypass through parameter manipulation', async ({ page }) => {
      console.log('ðŸ”’ Testing authorization bypass prevention');

      await page.goto('/people');
      await page.waitForLoadState('networkidle');

      // Test various authorization bypass techniques
      const bypassAttempts = [
        // Role escalation attempts
        { param: 'role', value: 'admin' },
        { param: 'user_type', value: 'administrator' },
        { param: 'privileges', value: 'full' },
        
        // User ID manipulation
        { param: 'user_id', value: '1' },
        { param: 'id', value: '../admin' },
        { param: 'user', value: '../../root' },
        
        // Boolean bypass
        { param: 'is_admin', value: 'true' },
        { param: 'authenticated', value: '1' }
      ];

      for (const attempt of bypassAttempts) {
        console.log(`Testing authorization bypass: ${attempt.param}=${attempt.value}`);
        
        // Try manipulating URL parameters
        const currentUrl = page.url();
        const urlWithBypass = `${currentUrl}?${attempt.param}=${attempt.value}`;
        
        await page.goto(urlWithBypass);
        await page.waitForLoadState('networkidle');
        
        // Check if unauthorized access was granted
        const unauthorizedAccess = await page.locator('[data-testid="admin-panel"], .admin-only, .privileged-content').count();
        expect(unauthorizedAccess).toBe(0);
        
        console.log(`âœ… Authorization bypass blocked: ${attempt.param}=${attempt.value}`);
      }
    });

    test('should validate JWT token security (if applicable)', async ({ page }) => {
      console.log('ðŸ”’ Testing JWT token security');

      // Check for JWT tokens in localStorage or cookies
      const tokens = await page.evaluate(() => {
        const localStorageTokens = [];
        const cookieTokens = [];
        
        // Check localStorage for tokens
        for (let i = 0; i < localStorage.length; i++) {
          const key = localStorage.key(i);
          const value = localStorage.getItem(key);
          if (value && (value.includes('eyJ') || key.includes('token') || key.includes('jwt'))) {
            localStorageTokens.push({ key, value: value.substring(0, 50) + '...' });
          }
        }
        
        // Check cookies for tokens
        document.cookie.split(';').forEach(cookie => {
          const [name, value] = cookie.split('=');
          if (value && (value.includes('eyJ') || name.includes('token') || name.includes('jwt'))) {
            cookieTokens.push({ name: name.trim(), value: value.substring(0, 50) + '...' });
          }
        });
        
        return { localStorage: localStorageTokens, cookies: cookieTokens };
      });

      if (tokens.localStorage.length > 0 || tokens.cookies.length > 0) {
        console.log('JWT tokens found - validating security...');
        
        // Test for common JWT vulnerabilities would go here
        // This is a placeholder for JWT-specific security tests
        console.log('âœ… JWT token security validation placeholder');
      } else {
        console.log('â„¹ï¸ No JWT tokens found in application');
      }
    });
  });

  test.describe('Input Validation and Sanitization', () => {
    
    test('should validate all input fields against malicious content', async ({ page }) => {
      console.log('ðŸ”’ Testing comprehensive input validation');

      const maliciousInputs = [
        // Script injection variants
        '<script>fetch("/api/people").then(r=>r.json()).then(console.log)</script>',
        'javascript:void(fetch("/api/admin"))',
        'data:text/html,<script>alert("XSS")</script>',
        
        // Path traversal
        '../../../etc/passwd',
        '..\\..\\..\\windows\\system32\\config\\sam',
        
        // Command injection
        '; rm -rf / #',
        '| cat /etc/passwd',
        '& net user hacker password /add',
        
        // LDAP injection
        '*)(&(password=*))',
        '*)(mail=*))(|(mail=*',
        
        // XML/XXE injection
        '<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><root>&xxe;</root>',
        
        // Buffer overflow attempts
        'A'.repeat(10000),
        
        // Format string attacks
        '%x%x%x%x%x%x%x%x',
        
        // Null byte injection
        'test\x00.php',
        
        // Unicode bypasses
        '\uFEFF<script>alert("XSS")</script>',
        '\u003cscript\u003ealert("XSS")\u003c/script\u003e'
      ];

      await page.goto('/assignments');
      await page.waitForLoadState('networkidle');

      // Test creating assignment with malicious inputs
      const newButton = page.locator('button:has-text("New"), button:has-text("Add")');
      if (await newButton.count() > 0) {
        await newButton.first().click();
        await page.waitForTimeout(1000);

        for (const maliciousInput of maliciousInputs) {
          console.log(`Testing malicious input: ${maliciousInput.substring(0, 30)}...`);
          
          // Try in various input fields
          const inputFields = await page.locator('input[type="text"], input[type="email"], textarea, input:not([type="hidden"])').all();
          
          for (const field of inputFields.slice(0, 3)) { // Test first 3 fields to save time
            try {
              await field.fill(maliciousInput);
              await page.waitForTimeout(100);
              
              // Check if malicious content was properly sanitized
              const fieldValue = await field.inputValue();
              if (fieldValue.includes('<script>') || fieldValue.includes('javascript:')) {
                console.log(`âš ï¸ Potential XSS vulnerability in input field`);
              }
            } catch (error) {
              // Field might reject malicious input - this is good
              console.log(`âœ… Input rejected: ${maliciousInput.substring(0, 20)}...`);
            }
          }
        }

        // Close modal
        const closeButton = page.locator('button:has-text("Cancel"), button:has-text("Close")');
        if (await closeButton.count() > 0) {
          await closeButton.first().click();
        }
      }

      console.log('âœ… Input validation testing completed');
    });
  });
});