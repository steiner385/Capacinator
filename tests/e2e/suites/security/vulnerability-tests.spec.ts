/**
 * Advanced Security Vulnerability Testing Suite
 * Validates protection against common web security vulnerabilities:
 * - Cross-Site Scripting (XSS) - Stored and Reflected
 * - Cross-Site Request Forgery (CSRF)
 * - SQL Injection (Advanced patterns)
 * - Content Security Policy (CSP) violations
 * - Session fixation and hijacking
 * - Authorization bypass attempts
 * Uses dynamic test data for proper isolation
 */
import { test, expect, tags } from '../../fixtures';
import { TestDataContext } from '../../utils/test-data-helpers';
test.describe('Advanced Security Vulnerability Testing', () => {
  let testContext: TestDataContext;
  let testData: any;
  test.beforeEach(async ({ testDataHelpers, apiContext }) => {
    // Create isolated test context
    testContext = testDataHelpers.createTestContext('vulnsec');
    // Create test data
    testData = await testDataHelpers.createBulkTestData(testContext, {
      projects: 2,
      people: 2,
      assignments: 2
    });
  });
  test.afterEach(async ({ testDataHelpers }) => {
    // Clean up all test data
    await testDataHelpers.cleanupTestContext(testContext);
  });
  test.describe('Cross-Site Scripting (XSS) Protection', () => {
    test(`${tags.security} ${tags.critical} should prevent stored XSS in project names`, async ({ 
      authenticatedPage,
      testHelpers,
      testDataHelpers 
    }) => {
      console.log('🔒 Testing stored XSS prevention in project creation');
      const xssPayloads = [
        '<script>alert("XSS")</script>',
        '<img src=x onerror=alert("XSS")>',
        'javascript:alert("XSS")',
        '<svg onload=alert("XSS")>',
        '"><script>alert("XSS")</script>',
        '<iframe src="javascript:alert(\'XSS\')"></iframe>',
        '<body onload=alert("XSS")>',
        '<div style="expression(alert(\'XSS\'))">',
        '<meta http-equiv="refresh" content="0;url=javascript:alert(\'XSS\')">'
      ];
      await testHelpers.navigateTo('/projects');
      await testHelpers.waitForPageReady();
      // Set up alert handler to catch any XSS attempts
      let xssTriggered = false;
      authenticatedPage.on('dialog', async dialog => {
        xssTriggered = true;
        await dialog.dismiss();
      });
      for (const payload of xssPayloads) {
        console.log(`Testing XSS payload: ${payload.substring(0, 30)}...`);
        // Try to create project with XSS payload
        const newButton = authenticatedPage.locator('button:has-text("New"), button:has-text("Add"), button:has-text("Create")');
        if (await newButton.count() > 0) {
          await newButton.first().click();
          await authenticatedPage.waitForTimeout(1000);
          // Use unique name with test context prefix
          const projectName = `${testContext.prefix}_${payload}`;
          const nameField = authenticatedPage.locator('input[name*="name"], input[placeholder*="name"]').first();
          if (await nameField.count() > 0) {
            await nameField.fill(projectName);
            // Fill other required fields
            const startDate = authenticatedPage.locator('input[name*="start"], input[type="date"]').first();
            const endDate = authenticatedPage.locator('input[name*="end"], input[type="date"]').last();
            if (await startDate.count() > 0) {
              await startDate.fill(new Date().toISOString().split('T')[0]);
            }
            if (await endDate.count() > 0) {
              const futureDate = new Date();
              futureDate.setMonth(futureDate.getMonth() + 6);
              await endDate.fill(futureDate.toISOString().split('T')[0]);
            }
            const submitButton = authenticatedPage.locator('button:has-text("Create"), button:has-text("Save")');
            if (await submitButton.count() > 0) {
              await submitButton.click();
              await authenticatedPage.waitForTimeout(2000);
            }
          }
          // Close modal if still open
          const modalStillOpen = await authenticatedPage.locator('.modal, [role="dialog"]').count() > 0;
          if (modalStillOpen) {
            const closeButton = authenticatedPage.locator('button:has-text("Cancel"), button:has-text("Close")');
            if (await closeButton.count() > 0) {
              await closeButton.first().click();
              await authenticatedPage.waitForTimeout(500);
            }
          }
        }
        // Verify XSS was not executed
        expect(xssTriggered).toBe(false);
        // Check page content doesn't contain unescaped script tags
        const pageContent = await authenticatedPage.content();
        expect(pageContent).not.toMatch(/<script[^>]*>alert/);
        console.log(`✅ XSS payload properly sanitized: ${payload.substring(0, 20)}...`);
      }
    });
    test(`${tags.security} should prevent reflected XSS in search parameters`, async ({ 
      authenticatedPage,
      testHelpers,
      testDataHelpers 
    }) => {
      console.log('🔒 Testing reflected XSS prevention in search');
      const reflectedXSSPayloads = [
        '<script>alert("Reflected XSS")</script>',
        '"><img src=x onerror=alert("XSS")>',
        'javascript:alert(document.cookie)',
        '%3Cscript%3Ealert("XSS")%3C/script%3E'
      ];
      // Set up alert handler
      let xssTriggered = false;
      authenticatedPage.on('dialog', async dialog => {
        xssTriggered = true;
        await dialog.dismiss();
      });
      for (const payload of reflectedXSSPayloads) {
        console.log(`Testing reflected XSS: ${payload.substring(0, 30)}...`);
        // Test in various pages with search functionality
        const pagesWithSearch = ['/assignments', '/projects', '/people'];
        for (const page of pagesWithSearch) {
          await testHelpers.navigateTo(page);
          await testHelpers.waitForPageReady();
          const searchField = authenticatedPage.locator('input[placeholder*="search"], input[name*="search"], input[type="search"]').first();
          if (await searchField.count() > 0) {
            await searchField.fill(payload);
            await authenticatedPage.waitForTimeout(1000);
            // Also try submitting search if there's a button
            const searchButton = authenticatedPage.locator('button[type="submit"], button:has-text("Search")');
            if (await searchButton.count() > 0) {
              await searchButton.click();
              await authenticatedPage.waitForTimeout(1000);
            }
          }
        }
        // Verify XSS was not triggered
        expect(xssTriggered).toBe(false);
        // Check page content
        const pageContent = await authenticatedPage.content();
        expect(pageContent).not.toMatch(/<script[^>]*>alert/);
        expect(pageContent).not.toMatch(/javascript:/);
        console.log(`✅ Reflected XSS prevented: ${payload.substring(0, 20)}...`);
      }
    });
    test(`${tags.security} should sanitize user input in person profiles`, async ({ 
      authenticatedPage,
      testHelpers,
      testDataHelpers 
    }) => {
      console.log('🔒 Testing XSS prevention in person profile fields');
      await testHelpers.navigateTo('/people');
      await testHelpers.waitForPageReady();
      const xssInProfilePayloads = [
        { field: 'name', payload: '<script>document.cookie="hijacked=true"</script>' },
        { field: 'email', payload: 'test@<img src=x onerror=alert("XSS")>.com' },
        { field: 'role', payload: '<svg><script>alert("XSS")</script></svg>' }
      ];
      const newButton = authenticatedPage.locator('button:has-text("New"), button:has-text("Add")');
      if (await newButton.count() > 0) {
        await newButton.first().click();
        await authenticatedPage.waitForTimeout(1000);
        for (const { field, payload } of xssInProfilePayloads) {
          console.log(`Testing profile XSS in ${field}: ${payload.substring(0, 30)}...`);
          const inputField = authenticatedPage.locator(`input[name*="${field}"], input[placeholder*="${field}"]`).first();
          if (await inputField.count() > 0) {
            await inputField.fill(`${testContext.prefix}_${payload}`);
            await authenticatedPage.waitForTimeout(500);
          }
        }
        // Try to submit (may fail validation)
        const submitButton = authenticatedPage.locator('button:has-text("Create"), button:has-text("Save")');
        if (await submitButton.count() > 0) {
          await submitButton.click();
          await authenticatedPage.waitForTimeout(1000);
        }
        // Verify no script execution
        const pageContent = await authenticatedPage.content();
        expect(pageContent).not.toMatch(/<script[^>]*>document\.cookie/);
        console.log('✅ Profile XSS payloads sanitized');
      }
    });
  });
  test.describe('CSRF and Session Security', () => {
    test(`${tags.security} should validate CSRF tokens on state-changing operations`, async ({ 
      authenticatedPage,
      testHelpers,
      apiContext 
    }) => {
      console.log('🔒 Testing CSRF protection');
      // Monitor API requests for CSRF tokens
      const apiRequests = [];
      authenticatedPage.on('request', request => {
        if (request.method() === 'POST' || request.method() === 'PUT' || request.method() === 'DELETE') {
          apiRequests.push({
            method: request.method(),
            url: request.url(),
            headers: request.headers()
          });
        }
      });
      // Perform state-changing operation
      await testHelpers.navigateTo('/assignments');
      await testHelpers.waitForPageReady();
      const newButton = authenticatedPage.locator('button:has-text("New")');
      if (await newButton.count() > 0) {
        await newButton.click();
        await authenticatedPage.waitForTimeout(1000);
        // Fill minimal form data
        const personSelect = authenticatedPage.locator('select[name*="person"]');
        const projectSelect = authenticatedPage.locator('select[name*="project"]');
        if (await personSelect.count() > 0 && await projectSelect.count() > 0) {
          await personSelect.selectOption({ index: 1 });
          await projectSelect.selectOption({ index: 1 });
        }
        const submitButton = authenticatedPage.locator('button:has-text("Create")');
        if (await submitButton.count() > 0) {
          await submitButton.click();
          await authenticatedPage.waitForTimeout(2000);
        }
      }
      // Verify CSRF protection exists
      if (apiRequests.length > 0) {
        const hasCSRFProtection = apiRequests.some(req => 
          req.headers['x-csrf-token'] || 
          req.headers['x-xsrf-token'] ||
          req.headers['csrf-token']
        );
        if (hasCSRFProtection) {
          console.log('✅ CSRF tokens present in requests');
        } else {
          console.log('ℹ️ No explicit CSRF tokens found (may use other protection methods)');
        }
      }
    });
    test(`${tags.security} should prevent session fixation attacks`, async ({ 
      authenticatedPage,
      testHelpers,
      page 
    }) => {
      console.log('🔒 Testing session fixation prevention');
      // Get current session ID
      const originalSession = await authenticatedPage.evaluate(() => {
        return localStorage.getItem('capacinator_current_user');
      });
      expect(originalSession).toBeTruthy();
      const originalUser = JSON.parse(originalSession);
      // Attempt session fixation by injecting different session
      const fixatedSession = {
        ...originalUser,
        id: 'fixated-session-id',
        name: 'Attacker Session'
      };
      await authenticatedPage.evaluate((session) => {
        localStorage.setItem('capacinator_current_user', JSON.stringify(session));
      }, fixatedSession);
      // Navigate to verify session handling
      await authenticatedPage.goto('/dashboard');
      await authenticatedPage.waitForLoadState('networkidle', { timeout: 30000 });
      // System should either:
      // 1. Reject the fixated session and require re-login
      // 2. Generate a new session ID
      const currentSession = await authenticatedPage.evaluate(() => {
        return localStorage.getItem('capacinator_current_user');
      });
      if (currentSession) {
        const currentUser = JSON.parse(currentSession);
        // Session should not be the fixated one
        expect(currentUser.id).not.toBe('fixated-session-id');
        console.log('✅ Session fixation prevented - original session maintained');
      } else {
        // Session was cleared, requiring re-login
        const loginRequired = await authenticatedPage.locator('#person-select').isVisible();
        expect(loginRequired).toBe(true);
        console.log('✅ Session fixation prevented - session cleared');
      }
    });
  });
  test.describe('Authorization Bypass Prevention', () => {
    test(`${tags.security} ${tags.api} should prevent unauthorized API access`, async ({ 
      apiContext,
      testDataHelpers 
    }) => {
      console.log('🔒 Testing authorization bypass prevention');
      // Try to access/modify resources belonging to other contexts
      const unauthorizedTests = [
        {
          method: 'PUT',
          description: 'Update project without permission',
          endpoint: `/api/projects/${testData.projects[0].id}`,
          data: { name: 'Unauthorized Update' }
        },
        {
          method: 'DELETE',
          description: 'Delete assignment without permission',
          endpoint: `/api/assignments/${testData.assignments[0].id}`
        },
        {
          method: 'GET',
          description: 'Access private user data',
          endpoint: `/api/people/${testData.people[0].id}/sensitive`
        }
      ];
      for (const test of unauthorizedTests) {
        console.log(`Testing: ${test.description}`);
        let response;
        try {
          if (test.method === 'GET') {
            response = await apiContext.get(test.endpoint);
          } else if (test.method === 'PUT') {
            response = await apiContext.put(test.endpoint, { data: test.data });
          } else if (test.method === 'DELETE') {
            response = await apiContext.delete(test.endpoint);
          }
          // Should either succeed (authorized) or return appropriate error
          if (response.ok()) {
            console.log(`ℹ️ ${test.description}: Allowed (user has permission)`);
          } else {
            expect([401, 403, 404]).toContain(response.status());
            console.log(`✅ ${test.description}: Blocked (${response.status()})`);
          }
        } catch (error) {
          console.log(`✅ ${test.description}: Request failed (blocked)`);
        }
      }
    });
    test(`${tags.security} should prevent privilege escalation`, async ({ 
      authenticatedPage,
      testHelpers,
      apiContext 
    }) => {
      console.log('🔒 Testing privilege escalation prevention');
      // Try to modify user role/permissions
      const currentUser = await authenticatedPage.evaluate(() => {
        const stored = localStorage.getItem('capacinator_current_user');
        return stored ? JSON.parse(stored) : null;
      });
      if (currentUser) {
        // Attempt to escalate privileges in localStorage
        const escalatedUser = {
          ...currentUser,
          role: 'admin',
          permissions: ['*'],
          isAdmin: true
        };
        await authenticatedPage.evaluate((user) => {
          localStorage.setItem('capacinator_current_user', JSON.stringify(user));
        }, escalatedUser);
        // Try to access admin functionality
        await testHelpers.navigateTo('/settings');
        // Check if we gained unauthorized access
        const adminSection = authenticatedPage.locator('[data-testid="admin-section"], .admin-only');
        if (await adminSection.count() > 0) {
          // If admin section exists, verify it's properly protected
          const isVisible = await adminSection.isVisible();
          if (isVisible && !currentUser.isAdmin) {
            throw new Error('Privilege escalation successful - CRITICAL SECURITY ISSUE');
          }
        }
        console.log('✅ Privilege escalation prevented');
      }
    });
  });
  test.describe('Content Security', () => {
    test(`${tags.security} should enforce Content Security Policy`, async ({ 
      authenticatedPage,
      testHelpers 
    }) => {
      console.log('🔒 Testing Content Security Policy');
      // Check for CSP violations
      const cspViolations = [];
      authenticatedPage.on('console', msg => {
        if (msg.text().includes('Content Security Policy') || msg.text().includes('CSP')) {
          cspViolations.push(msg.text());
        }
      });
      await testHelpers.navigateTo('/dashboard');
      // Try to inject inline script
      try {
        await authenticatedPage.evaluate(() => {
          const script = document.createElement('script');
          script.textContent = 'console.log("Inline script executed")';
          document.head.appendChild(script);
        });
      } catch (error) {
        console.log('✅ Inline script blocked by CSP');
      }
      // Check response headers for CSP
      const response = await authenticatedPage.goto('/');
      const cspHeader = response.headers()['content-security-policy'];
      if (cspHeader) {
        console.log('✅ Content Security Policy header present');
        expect(cspHeader).toContain('default-src');
      } else {
        console.log('ℹ️ No CSP header found (consider implementing)');
      }
      if (cspViolations.length > 0) {
        console.log(`ℹ️ CSP violations detected: ${cspViolations.length}`);
      }
    });
  });
});